import time
import logging
import random
from typing import List, Dict
from sqlalchemy import text
from sqlalchemy.engine.base import Engine

def run_ideation(engine: Engine, use_gemini) -> List[Dict]:
    """
    Simulate an ideation process step-by-step, yielding logs as they occur.
    At the end, retrieve DB entries and use the Gemini LLM to generate ideas.

    :param engine: SQLAlchemy Engine to connect to the database.
    :param use_gemini: A callable that takes a prompt string and returns a list of idea dicts.
    :yield: Steps of the ideation process as strings.
    :return: A list of idea dictionaries generated by the LLM.
    """
    steps = [
        "Initiating ideation process...",
        "Analyzing available APIs from the database...",
        "Formulating a prompt for Gemini LLM...",
        "Asking Gemini for innovative API combination ideas...",
        "Finalizing ideas..."
    ]
    
    for step in steps:
        yield step
        time.sleep(1)
    
    # After yielding steps, we now try to generate ideas using Gemini LLM
    ideas = generate_ideas_with_llm(engine, use_gemini)
    return ideas

def generate_ideas_with_llm(engine: Engine, use_gemini, num_ideas: int = 3) -> List[Dict]:
    """
    Generate idea concepts based on APIs from the DB by calling the Gemini LLM.

    :param engine: SQLAlchemy engine for DB connection.
    :param use_gemini: A function to call the LLM. It takes a prompt and returns a list of ideas.
    :param num_ideas: Number of ideas to request from the LLM.
    :return: A list of idea dictionaries.
    """
    entries = fetch_db_entries(engine)
    if not entries:
        logging.debug("No entries found in DB. Returning fallback idea.")
        return [{
            "title": "No APIs Found",
            "description": "No entries available in the database to generate ideas.",
            "apis_used": []
        }]

    # Construct a prompt for the LLM
    prompt = construct_llm_prompt(entries, num_ideas)

    # Call the LLM and handle exceptions
    try:
        ideas = use_gemini(prompt)
        logging.debug("LLM returned ideas successfully.")
        return ideas
    except Exception as e:
        logging.error("Failed to get ideas from LLM: %s", e)
        # Fallback idea if LLM fails
        return [{
            "title": "LLM Error",
            "description": "There was an error generating ideas using the LLM.",
            "apis_used": []
        }]

def fetch_db_entries(engine: Engine) -> List[Dict]:
    """
    Fetch API entries from the database and return them as a list of dictionaries.

    :param engine: SQLAlchemy engine for DB connection.
    :return: List of dicts containing API entry info.
    """
    try:
        with engine.connect() as conn:
            result = conn.execute(text("SELECT name, category, base_url, endpoint, description FROM apientry"))
            rows = result.fetchall()
        entries = []
        for row in rows:
            entry = {
                "name": row.name,
                "category": row.category,
                "base_url": row.base_url,
                "endpoint": row.endpoint,
                "description": row.description
            }
            entries.append(entry)
        return entries
    except Exception as e:
        logging.error("Failed to fetch entries from DB: %s", e)
        return []

def construct_llm_prompt(entries: List[Dict], num_ideas: int) -> str:
    """
    Construct a prompt string for the LLM based on the database entries.

    :param entries: List of API entry dictionaries.
    :param num_ideas: Number of ideas to request from the LLM.
    :return: A prompt string for the LLM.
    """
    # Summarize the available APIs
    # We'll list their names, categories, and brief descriptions.
    apis_summary_lines = []
    for e in entries:
        line = f"- Name: {e['name']} | Category: {e['category']} | Description: {e['description']}"
        apis_summary_lines.append(line)

    apis_summary = "\n".join(apis_summary_lines)

    prompt = f"""
You have access to a set of APIs. Each API has a name, category, and description:

{apis_summary}

Please propose {num_ideas} innovative application ideas that combine these APIs in interesting ways. 
For each idea, provide:
- A short title
- A concise description of what the application does
- A list of the APIs (by name) that it would use

Return your answer as a JSON list, where each element is a dictionary with keys: "title", "description", and "apis_used".
    """

    return prompt.strip()
