from src.config.setup import initialize_genai_client
from src.db.crud import fetch_db_entries_by_names
from src.llm.gemini_text import generate_content
from src.config.setup import TEMPLATES_DIR
from src.db.crud import fetch_db_entries
from src.config.logging import logger
from src.config.setup import MODEL
from typing import Tuple, Dict, List
import pandas as pd
import random
import re

# File paths for templates
IDEATE_TEMPLATE_PATH = TEMPLATES_DIR + '/ideate.txt'
BUILD_TEMPLATE_PATH = TEMPLATES_DIR + '/build.txt'

# Markers for code extraction
FRONTEND_MARKERS = ("---BEGIN FRONTEND CODE---", "---END FRONTEND CODE---")
BACKEND_MARKERS = ("---BEGIN BACKEND CODE---", "---END BACKEND CODE---")

def build_prompt(entries: List[Dict[str, str]], num_ideas: int) -> str:
    """
    Builds a prompt using provided API entries and the number of ideas to generate.

    Args:
        entries (List[Dict[str, str]]): List of API entry dictionaries containing name, category, and description.
        num_ideas (int): Number of ideas to generate.

    Returns:
        str: Formatted prompt string.
    """
    apis_summary = "\n".join([
        f"- Name: {entry['name']} | Category: {entry['category']} | Description: {entry['description']}"
        for entry in entries
    ])

    try:
        with open(IDEATE_TEMPLATE_PATH, 'r', encoding='utf-8') as f:
            template = f.read()
        logger.info("Prompt template loaded successfully.")
    except FileNotFoundError as e:
        logger.error(f"Ideation template file not found: {e}")
        raise

    return template.format(apis_summary=apis_summary, num_ideas=num_ideas).strip()

def extract_ideas_from_response(response: str) -> List[Dict[str, List[str]]]:
    """
    Extracts ideas from the response text generated by the LLM.

    Args:
        response (str): Response text from the LLM.

    Returns:
        List[Dict[str, List[str]]]: List of dictionaries containing idea titles, descriptions, and APIs used.
    """
    pattern = re.compile(
        r"^Title:\s*([A-Za-z_]+)\r?\n"
        r"Description:\s*(.+?)\r?\n"
        r"APIs Used:\s*(.+)$",
        re.IGNORECASE | re.MULTILINE
    )

    ideas = []
    raw_ideas = [block.strip() for block in response.strip().split("\n\n") if block.strip()]

    for idea_text in raw_ideas:
        match = pattern.search(idea_text)
        if match:
            title = match.group(1).strip()
            description = match.group(2).strip()
            apis_used_line = match.group(3).strip()
            apis_used = [api.strip() for api in apis_used_line.split(",") if api.strip()]

            if title and description and apis_used:
                ideas.append({
                    "title": title,
                    "description": description,
                    "apis_used": apis_used
                })

    if not ideas:
        logger.warning("No valid ideas extracted from response.")
        return [{
            "title": "LLM Error",
            "description": "No valid ideas could be extracted.",
            "apis_used": []
        }]

    return ideas

def generate_ideas(num_ideas: int = 3, selected_names: List[str] = None) -> List[Dict[str, List[str]]]:
    """
    Generates a specified number of ideas based on API entries.

    Args:
        num_ideas (int, optional): Number of ideas to generate. Defaults to 3.
        selected_names (List[str], optional): List of specific API names to fetch. Defaults to None.

    Returns:
        List[Dict[str, List[str]]]: List of generated ideas.
    """
    try:
        if selected_names:
            entries = fetch_db_entries_by_names(selected_names)
        else:
            all_entries = fetch_db_entries()
            if not all_entries:
                logger.warning("No API entries available.")
                return [{
                    "title": "No APIs Found",
                    "description": "No entries available.",
                    "apis_used": []
                }]
            sample_size = min(3, len(all_entries))
            entries = random.sample(all_entries, sample_size)

        prompt = build_prompt(entries, num_ideas)
        client = initialize_genai_client()
        response = generate_content(client, MODEL, prompt)
        logger.info("Generated ideas successfully.")
        return extract_ideas_from_response(response.text)
    except Exception as e:
        logger.error(f"Error during idea generation: {e}")
        raise

def extract_code_block(response: str, markers: Tuple[str, str]) -> str:
    """
    Extracts a code block from the response based on provided markers.

    Args:
        response (str): Response text from the LLM.
        markers (Tuple[str, str]): Start and end markers for the code block.

    Returns:
        str: Extracted code block or a message indicating no code block was found.
    """
    start_marker, end_marker = markers
    try:
        code_section = response.split(start_marker, 1)[1].split(end_marker, 1)[0]
        code_block = re.search(r"```(.*?)```", code_section, re.DOTALL)
        if code_block:
            return code_block.group(1).strip()
        return code_section.strip()
    except (IndexError, AttributeError) as e:
        logger.warning(f"No code block found for markers {markers}: {e}")
        return f"# No code block found for section: {start_marker}"

def build_app_code(selected_ideas: List[Dict[str, List[str]]], app_name_slug: str, entries: pd.DataFrame) -> Tuple[str, str]:
    """
    Builds frontend and backend code for an application based on selected ideas and entries.

    Args:
        selected_ideas (List[Dict[str, List[str]]]): List of selected ideas with titles, descriptions, and APIs used.
        app_name_slug (str): Slugified name for the application.
        entries (pd.DataFrame): DataFrame containing API entries.

    Returns:
        Tuple[str, str]: Frontend and backend code blocks as strings.
    """
    try:
        client = initialize_genai_client()
        ideas_summary = "\n\n".join([
            f"Title: {idea['title']}\nDescription: {idea['description']}\nAPIs Used: {', '.join(idea['apis_used'])}"
            for idea in selected_ideas
        ])

        apis_summary = "No entries found."
        if not entries.empty:
            apis_summary = "APIs Table:\n" + entries.to_csv(index=False)

        with open(BUILD_TEMPLATE_PATH, 'r', encoding='utf-8') as f:
            template = f.read()

        prompt = template.format(ideas_text=ideas_summary, entries_text=apis_summary, app_name_slug=app_name_slug)
        response = generate_content(client, MODEL, prompt)

        frontend_code = extract_code_block(response.text, FRONTEND_MARKERS)
        backend_code = extract_code_block(response.text, BACKEND_MARKERS)

        logger.info("Application code generated successfully.")
        return frontend_code, backend_code

    except Exception as e:
        logger.error(f"Error during application code generation: {e}")
        raise
